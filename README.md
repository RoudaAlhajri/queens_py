# queens_py


# Creating Python programs to solve the two issues mentioned in unit 9 report  in Codio

### Database
To get started with the development, the system needs a database to apply the solutions on. Thus, I used sqlite3 with python.
Using sqlite with python requires libraries installation. Therefore, through Codio’s web tab page for unit 12 development. Open the terminal and issue the following command.

“””Ptyhon

pip install pysqlite3 

“””


Once the database is installed as a package for the python. The development has been carried on to the creation of database table. This table is for demonstrating the hashing password with sha265.

The code is in **create_db_table.py script as following:


'''

#!/usr/bin/python

import sqlite3
def create_table():
  conn = sqlite3.connect('queens.db') 
  print("Opened database successfully")
  conn.execute('''CREATE TABLE users(ID INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL ,NAME TEXT NOT NULL,username TEXT NOT NULL,password TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50));''')
  print("Table created successfully")
  conn.close()



create_table()

'''


### Run the Script 

python3  create_db_table.py

**results 
codio@societyravioli-dependopus:~/workspace$ python3 sl.py
Opened database successfully
Table created successfully





### Hashing and sha256 for passwords.
The code below shows the three functions of how the hashing is implemented. First the ***generate_hash function, which have one parameter and return hashed data. Second the ***add_user functions with five parameters to create a a new user. And finally the **login function which asks the user to enter username and password, then it uses the **generate_hash function to gerate a hash of the password which it will be compared with the hashed password stored in the database.
Additionally, to run the ***add ***user function, just uncomment the input the the function call. And comment the **login function 

'''

#!/usr/bin/python
from hashlib import sha256
import sqlite3
#this function to hash the password 
#before using it or comparing it to the database record
def generate_hash(value):
  return(sha256(value.encode('utf-8')).hexdigest())

# to create a new user
def add_user(NAME,username, password, AGE,ADDRESS):
  
  password=generate_hash(password)
  conn.execute("INSERT INTO users (NAME,username, password, AGE,ADDRESS) VALUES ( '"+str(NAME)+"', '"+str(username)+"', '"+str(password)+"', '"+str(AGE)+"', '"+str(ADDRESS)+"')")


  conn.commit()
  print("user added successfully")
  

def login():

  username_ = input('username: ')
  password_ = input('password: ')
  password=generate_hash(password_)
  sqlstr="SELECT id, name, address from users where username='"+str(username_)+"' and password='"+str(password)+"'"
  cursor = conn.execute(sqlstr)
  for row in cursor:
    print ("ID = ", row[0])
    print ("NAME = ", row[1])
    print ("ADDRESS = ", row[2])

conn = sqlite3.connect('queens.db')
print("Opened database successfully")
#name_ = input('Name: ')
#username_ = input('username: ')
#password_ = input('password: ')
#age_ = input('age: ')
#address_ = input('address: ')
#add_user(name_,username_, password_, age_,address_)
login()

conn.close()



'''










### run hashing script.
As desired the user shall comment the unneeded function and allow other lines of code to be executed. Prior to what mentioned, this script contains 3 functions.

**to run the script
**- Open terminal.
Issue the command **python3 **hashing.py 
There is an already inserted user under the username: sarah and password:sa22 for testing.

![playGuide]([https://global.codio.com/platform/readme.resources/playGuide.pn](https://github.com/RoudaAlhajri/queens_py/blob/main/Screen%20Shot%202022-12-12%20at%204.42.31%20PM.png?raw=true)g)



###SQL Injection 
The previous code illustrated the development of using irreversible hash code generated by SHA256. At this stage the code is at risk of being attacked by SQL Injection. Therefore, I used a simple technique to reduce this risk. However, there are a vast number of methods and mostly used one is string_escape function such this one available built in MySQL libraries. The main issue with SQL injections are when the user input is not handled in the correct way leaving the attacker with a chance. 
For example 
“select * from users where id={input_id}”
the user can get all the records by simply entering this as an **ID: 10  or 1=1
Which will basically work as 1=1  and true.

 Nonetheless,  my implementation is following: 


uid = input('id: ')
id=uid.replace(" ", "")

